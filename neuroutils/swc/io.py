# Parse SWC files and extract neuron tree structures
import os
import pandas as pd
from joblib import Parallel, delayed
from neuroutils.meta.mapping import extract_neuron_id
from neuroutils.meta.neuron import get_neuron_meta
from neuroutils.config.settings import DEFAULT_RESOLUTION_UNIT, DEFAULT_NUM_THREADS
from collections import defaultdict, deque
from tqdm import tqdm

def load_swc(swc_file):
    swc = pd.read_csv(swc_file, sep=' ', header=None, comment='#')
    swc.columns = ['n', 'type', 'x', 'y', 'z', 'r', 'parent']
    # 数据类型转换
    swc['n'] = swc['n'].astype(int)
    swc['type'] = swc['type'].astype(int)
    swc['x'] = swc['x'].astype(float)
    swc['y'] = swc['y'].astype(float)
    swc['z'] = swc['z'].astype(float)
    swc['r'] = swc['r'].astype(float)
    swc['parent'] = swc['parent'].astype(int)

    try:
        neuron_id = extract_neuron_id(swc_file)
    except Exception as e:
        neuron_id = "unknown"
    swc['neuron_id'] = neuron_id

    return swc

def save_swc(swc, output_file):
    # print(swc)
    swc = swc[['n', 'type', 'x', 'y', 'z', 'r', 'parent']]
    # Save the SWC DataFrame to a file
    with open(output_file, 'w') as f:
        f.write('# Generated by Neuroutils\n')
        f.write('#\n')
        f.write('# id type x y z radius parent\n')
        swc.to_csv(f, sep=' ', index=False, header=False)
#
# def rescale_swc(swc, xy_resolution=None, z_resolution=None):
#     if(xy_resolution is None) and (z_resolution is None):
#         meta = get_neuron_meta(swc['neuron_id'].iloc[0])
#         xy_resolution = float(meta['xy_resolution']) / DEFAULT_RESOLUTION_UNIT
#         z_resolution = float(meta['z_resolution']) / DEFAULT_RESOLUTION_UNIT
#     swc['x'] *= xy_resolution
#     swc['y'] *= xy_resolution
#     swc['z'] *= z_resolution
#     return swc

def is_valid_tree_swc(swc_df):
    # 条件1: 唯一根节点
    roots = swc_df[swc_df['parent'] == -1]
    if len(roots) != 1:
        print("无效：根节点数量不为1")
        return False

    # 条件2: 节点编号唯一
    if swc_df['n'].duplicated().any():
        print("无效：节点编号重复")
        return False

    node_ids = set(swc_df['n'])
    parent_ids = set(swc_df['parent'])
    if not parent_ids.issubset(node_ids.union({-1})):
        print("无效：存在未知父节点")
        return False

    # 构建邻接表
    graph = defaultdict(list)
    root_id = roots.iloc[0]['n']
    for _, row in swc_df.iterrows():
        if row['parent'] != -1:
            graph[row['parent']].append(row['n'])

    # 条件3+4: 从根节点出发做DFS，判断连通性和无环性
    visited = set()
    stack = [(root_id, -1)]
    while stack:
        current, parent = stack.pop()
        if current in visited:
            print("无效：图中存在环")
            return False
        visited.add(current)
        for child in graph[current]:
            if child != parent:
                stack.append((child, current))

    if visited != node_ids:
        print("无效：图不连通")
        return False

    return True

def is_valid_swc_dir(swc_dir):
    swc_files = [os.path.join(swc_dir, f) for f in os.listdir(swc_dir) if f.endswith('.swc')]
    Parallel(n_jobs=DEFAULT_NUM_THREADS)(delayed(is_valid_tree_swc)(load_swc(swc_file)) for swc_file in tqdm(swc_files))

if __name__ == "__main__":
    swc_dir = "/data/kfchen/trace_ws/paper_auto_human_neuron_recon/swc_label/1um_swc_lab_resample_prune"
    is_valid_swc_dir(swc_dir)